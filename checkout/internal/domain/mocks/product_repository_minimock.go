package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/domain.ProductRepository -o ./mocks\product_repository_minimock.go -n ProductRepositoryMock

import (
	"context"
	mm_domain "route256/checkout/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ProductRepositoryMock implements domain.ProductRepository
type ProductRepositoryMock struct {
	t minimock.Tester

	funcGetListBySkus          func(ctx context.Context, skus []uint32) (ppa1 []*mm_domain.ProductInfo, err error)
	inspectFuncGetListBySkus   func(ctx context.Context, skus []uint32)
	afterGetListBySkusCounter  uint64
	beforeGetListBySkusCounter uint64
	GetListBySkusMock          mProductRepositoryMockGetListBySkus

	funcGetProductBySku          func(ctx context.Context, sku uint32) (pp1 *mm_domain.ProductInfo, err error)
	inspectFuncGetProductBySku   func(ctx context.Context, sku uint32)
	afterGetProductBySkuCounter  uint64
	beforeGetProductBySkuCounter uint64
	GetProductBySkuMock          mProductRepositoryMockGetProductBySku
}

// NewProductRepositoryMock returns a mock for domain.ProductRepository
func NewProductRepositoryMock(t minimock.Tester) *ProductRepositoryMock {
	m := &ProductRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetListBySkusMock = mProductRepositoryMockGetListBySkus{mock: m}
	m.GetListBySkusMock.callArgs = []*ProductRepositoryMockGetListBySkusParams{}

	m.GetProductBySkuMock = mProductRepositoryMockGetProductBySku{mock: m}
	m.GetProductBySkuMock.callArgs = []*ProductRepositoryMockGetProductBySkuParams{}

	return m
}

type mProductRepositoryMockGetListBySkus struct {
	mock               *ProductRepositoryMock
	defaultExpectation *ProductRepositoryMockGetListBySkusExpectation
	expectations       []*ProductRepositoryMockGetListBySkusExpectation

	callArgs []*ProductRepositoryMockGetListBySkusParams
	mutex    sync.RWMutex
}

// ProductRepositoryMockGetListBySkusExpectation specifies expectation struct of the ProductRepository.GetListBySkus
type ProductRepositoryMockGetListBySkusExpectation struct {
	mock    *ProductRepositoryMock
	params  *ProductRepositoryMockGetListBySkusParams
	results *ProductRepositoryMockGetListBySkusResults
	Counter uint64
}

// ProductRepositoryMockGetListBySkusParams contains parameters of the ProductRepository.GetListBySkus
type ProductRepositoryMockGetListBySkusParams struct {
	ctx  context.Context
	skus []uint32
}

// ProductRepositoryMockGetListBySkusResults contains results of the ProductRepository.GetListBySkus
type ProductRepositoryMockGetListBySkusResults struct {
	ppa1 []*mm_domain.ProductInfo
	err  error
}

// Expect sets up expected params for ProductRepository.GetListBySkus
func (mmGetListBySkus *mProductRepositoryMockGetListBySkus) Expect(ctx context.Context, skus []uint32) *mProductRepositoryMockGetListBySkus {
	if mmGetListBySkus.mock.funcGetListBySkus != nil {
		mmGetListBySkus.mock.t.Fatalf("ProductRepositoryMock.GetListBySkus mock is already set by Set")
	}

	if mmGetListBySkus.defaultExpectation == nil {
		mmGetListBySkus.defaultExpectation = &ProductRepositoryMockGetListBySkusExpectation{}
	}

	mmGetListBySkus.defaultExpectation.params = &ProductRepositoryMockGetListBySkusParams{ctx, skus}
	for _, e := range mmGetListBySkus.expectations {
		if minimock.Equal(e.params, mmGetListBySkus.defaultExpectation.params) {
			mmGetListBySkus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListBySkus.defaultExpectation.params)
		}
	}

	return mmGetListBySkus
}

// Inspect accepts an inspector function that has same arguments as the ProductRepository.GetListBySkus
func (mmGetListBySkus *mProductRepositoryMockGetListBySkus) Inspect(f func(ctx context.Context, skus []uint32)) *mProductRepositoryMockGetListBySkus {
	if mmGetListBySkus.mock.inspectFuncGetListBySkus != nil {
		mmGetListBySkus.mock.t.Fatalf("Inspect function is already set for ProductRepositoryMock.GetListBySkus")
	}

	mmGetListBySkus.mock.inspectFuncGetListBySkus = f

	return mmGetListBySkus
}

// Return sets up results that will be returned by ProductRepository.GetListBySkus
func (mmGetListBySkus *mProductRepositoryMockGetListBySkus) Return(ppa1 []*mm_domain.ProductInfo, err error) *ProductRepositoryMock {
	if mmGetListBySkus.mock.funcGetListBySkus != nil {
		mmGetListBySkus.mock.t.Fatalf("ProductRepositoryMock.GetListBySkus mock is already set by Set")
	}

	if mmGetListBySkus.defaultExpectation == nil {
		mmGetListBySkus.defaultExpectation = &ProductRepositoryMockGetListBySkusExpectation{mock: mmGetListBySkus.mock}
	}
	mmGetListBySkus.defaultExpectation.results = &ProductRepositoryMockGetListBySkusResults{ppa1, err}
	return mmGetListBySkus.mock
}

// Set uses given function f to mock the ProductRepository.GetListBySkus method
func (mmGetListBySkus *mProductRepositoryMockGetListBySkus) Set(f func(ctx context.Context, skus []uint32) (ppa1 []*mm_domain.ProductInfo, err error)) *ProductRepositoryMock {
	if mmGetListBySkus.defaultExpectation != nil {
		mmGetListBySkus.mock.t.Fatalf("Default expectation is already set for the ProductRepository.GetListBySkus method")
	}

	if len(mmGetListBySkus.expectations) > 0 {
		mmGetListBySkus.mock.t.Fatalf("Some expectations are already set for the ProductRepository.GetListBySkus method")
	}

	mmGetListBySkus.mock.funcGetListBySkus = f
	return mmGetListBySkus.mock
}

// When sets expectation for the ProductRepository.GetListBySkus which will trigger the result defined by the following
// Then helper
func (mmGetListBySkus *mProductRepositoryMockGetListBySkus) When(ctx context.Context, skus []uint32) *ProductRepositoryMockGetListBySkusExpectation {
	if mmGetListBySkus.mock.funcGetListBySkus != nil {
		mmGetListBySkus.mock.t.Fatalf("ProductRepositoryMock.GetListBySkus mock is already set by Set")
	}

	expectation := &ProductRepositoryMockGetListBySkusExpectation{
		mock:   mmGetListBySkus.mock,
		params: &ProductRepositoryMockGetListBySkusParams{ctx, skus},
	}
	mmGetListBySkus.expectations = append(mmGetListBySkus.expectations, expectation)
	return expectation
}

// Then sets up ProductRepository.GetListBySkus return parameters for the expectation previously defined by the When method
func (e *ProductRepositoryMockGetListBySkusExpectation) Then(ppa1 []*mm_domain.ProductInfo, err error) *ProductRepositoryMock {
	e.results = &ProductRepositoryMockGetListBySkusResults{ppa1, err}
	return e.mock
}

// GetListBySkus implements domain.ProductRepository
func (mmGetListBySkus *ProductRepositoryMock) GetListBySkus(ctx context.Context, skus []uint32) (ppa1 []*mm_domain.ProductInfo, err error) {
	mm_atomic.AddUint64(&mmGetListBySkus.beforeGetListBySkusCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListBySkus.afterGetListBySkusCounter, 1)

	if mmGetListBySkus.inspectFuncGetListBySkus != nil {
		mmGetListBySkus.inspectFuncGetListBySkus(ctx, skus)
	}

	mm_params := &ProductRepositoryMockGetListBySkusParams{ctx, skus}

	// Record call args
	mmGetListBySkus.GetListBySkusMock.mutex.Lock()
	mmGetListBySkus.GetListBySkusMock.callArgs = append(mmGetListBySkus.GetListBySkusMock.callArgs, mm_params)
	mmGetListBySkus.GetListBySkusMock.mutex.Unlock()

	for _, e := range mmGetListBySkus.GetListBySkusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmGetListBySkus.GetListBySkusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListBySkus.GetListBySkusMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListBySkus.GetListBySkusMock.defaultExpectation.params
		mm_got := ProductRepositoryMockGetListBySkusParams{ctx, skus}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListBySkus.t.Errorf("ProductRepositoryMock.GetListBySkus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListBySkus.GetListBySkusMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListBySkus.t.Fatal("No results are set for the ProductRepositoryMock.GetListBySkus")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmGetListBySkus.funcGetListBySkus != nil {
		return mmGetListBySkus.funcGetListBySkus(ctx, skus)
	}
	mmGetListBySkus.t.Fatalf("Unexpected call to ProductRepositoryMock.GetListBySkus. %v %v", ctx, skus)
	return
}

// GetListBySkusAfterCounter returns a count of finished ProductRepositoryMock.GetListBySkus invocations
func (mmGetListBySkus *ProductRepositoryMock) GetListBySkusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListBySkus.afterGetListBySkusCounter)
}

// GetListBySkusBeforeCounter returns a count of ProductRepositoryMock.GetListBySkus invocations
func (mmGetListBySkus *ProductRepositoryMock) GetListBySkusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListBySkus.beforeGetListBySkusCounter)
}

// Calls returns a list of arguments used in each call to ProductRepositoryMock.GetListBySkus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListBySkus *mProductRepositoryMockGetListBySkus) Calls() []*ProductRepositoryMockGetListBySkusParams {
	mmGetListBySkus.mutex.RLock()

	argCopy := make([]*ProductRepositoryMockGetListBySkusParams, len(mmGetListBySkus.callArgs))
	copy(argCopy, mmGetListBySkus.callArgs)

	mmGetListBySkus.mutex.RUnlock()

	return argCopy
}

// MinimockGetListBySkusDone returns true if the count of the GetListBySkus invocations corresponds
// the number of defined expectations
func (m *ProductRepositoryMock) MinimockGetListBySkusDone() bool {
	for _, e := range m.GetListBySkusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListBySkusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListBySkusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListBySkus != nil && mm_atomic.LoadUint64(&m.afterGetListBySkusCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListBySkusInspect logs each unmet expectation
func (m *ProductRepositoryMock) MinimockGetListBySkusInspect() {
	for _, e := range m.GetListBySkusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductRepositoryMock.GetListBySkus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListBySkusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListBySkusCounter) < 1 {
		if m.GetListBySkusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ProductRepositoryMock.GetListBySkus")
		} else {
			m.t.Errorf("Expected call to ProductRepositoryMock.GetListBySkus with params: %#v", *m.GetListBySkusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListBySkus != nil && mm_atomic.LoadUint64(&m.afterGetListBySkusCounter) < 1 {
		m.t.Error("Expected call to ProductRepositoryMock.GetListBySkus")
	}
}

type mProductRepositoryMockGetProductBySku struct {
	mock               *ProductRepositoryMock
	defaultExpectation *ProductRepositoryMockGetProductBySkuExpectation
	expectations       []*ProductRepositoryMockGetProductBySkuExpectation

	callArgs []*ProductRepositoryMockGetProductBySkuParams
	mutex    sync.RWMutex
}

// ProductRepositoryMockGetProductBySkuExpectation specifies expectation struct of the ProductRepository.GetProductBySku
type ProductRepositoryMockGetProductBySkuExpectation struct {
	mock    *ProductRepositoryMock
	params  *ProductRepositoryMockGetProductBySkuParams
	results *ProductRepositoryMockGetProductBySkuResults
	Counter uint64
}

// ProductRepositoryMockGetProductBySkuParams contains parameters of the ProductRepository.GetProductBySku
type ProductRepositoryMockGetProductBySkuParams struct {
	ctx context.Context
	sku uint32
}

// ProductRepositoryMockGetProductBySkuResults contains results of the ProductRepository.GetProductBySku
type ProductRepositoryMockGetProductBySkuResults struct {
	pp1 *mm_domain.ProductInfo
	err error
}

// Expect sets up expected params for ProductRepository.GetProductBySku
func (mmGetProductBySku *mProductRepositoryMockGetProductBySku) Expect(ctx context.Context, sku uint32) *mProductRepositoryMockGetProductBySku {
	if mmGetProductBySku.mock.funcGetProductBySku != nil {
		mmGetProductBySku.mock.t.Fatalf("ProductRepositoryMock.GetProductBySku mock is already set by Set")
	}

	if mmGetProductBySku.defaultExpectation == nil {
		mmGetProductBySku.defaultExpectation = &ProductRepositoryMockGetProductBySkuExpectation{}
	}

	mmGetProductBySku.defaultExpectation.params = &ProductRepositoryMockGetProductBySkuParams{ctx, sku}
	for _, e := range mmGetProductBySku.expectations {
		if minimock.Equal(e.params, mmGetProductBySku.defaultExpectation.params) {
			mmGetProductBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProductBySku.defaultExpectation.params)
		}
	}

	return mmGetProductBySku
}

// Inspect accepts an inspector function that has same arguments as the ProductRepository.GetProductBySku
func (mmGetProductBySku *mProductRepositoryMockGetProductBySku) Inspect(f func(ctx context.Context, sku uint32)) *mProductRepositoryMockGetProductBySku {
	if mmGetProductBySku.mock.inspectFuncGetProductBySku != nil {
		mmGetProductBySku.mock.t.Fatalf("Inspect function is already set for ProductRepositoryMock.GetProductBySku")
	}

	mmGetProductBySku.mock.inspectFuncGetProductBySku = f

	return mmGetProductBySku
}

// Return sets up results that will be returned by ProductRepository.GetProductBySku
func (mmGetProductBySku *mProductRepositoryMockGetProductBySku) Return(pp1 *mm_domain.ProductInfo, err error) *ProductRepositoryMock {
	if mmGetProductBySku.mock.funcGetProductBySku != nil {
		mmGetProductBySku.mock.t.Fatalf("ProductRepositoryMock.GetProductBySku mock is already set by Set")
	}

	if mmGetProductBySku.defaultExpectation == nil {
		mmGetProductBySku.defaultExpectation = &ProductRepositoryMockGetProductBySkuExpectation{mock: mmGetProductBySku.mock}
	}
	mmGetProductBySku.defaultExpectation.results = &ProductRepositoryMockGetProductBySkuResults{pp1, err}
	return mmGetProductBySku.mock
}

// Set uses given function f to mock the ProductRepository.GetProductBySku method
func (mmGetProductBySku *mProductRepositoryMockGetProductBySku) Set(f func(ctx context.Context, sku uint32) (pp1 *mm_domain.ProductInfo, err error)) *ProductRepositoryMock {
	if mmGetProductBySku.defaultExpectation != nil {
		mmGetProductBySku.mock.t.Fatalf("Default expectation is already set for the ProductRepository.GetProductBySku method")
	}

	if len(mmGetProductBySku.expectations) > 0 {
		mmGetProductBySku.mock.t.Fatalf("Some expectations are already set for the ProductRepository.GetProductBySku method")
	}

	mmGetProductBySku.mock.funcGetProductBySku = f
	return mmGetProductBySku.mock
}

// When sets expectation for the ProductRepository.GetProductBySku which will trigger the result defined by the following
// Then helper
func (mmGetProductBySku *mProductRepositoryMockGetProductBySku) When(ctx context.Context, sku uint32) *ProductRepositoryMockGetProductBySkuExpectation {
	if mmGetProductBySku.mock.funcGetProductBySku != nil {
		mmGetProductBySku.mock.t.Fatalf("ProductRepositoryMock.GetProductBySku mock is already set by Set")
	}

	expectation := &ProductRepositoryMockGetProductBySkuExpectation{
		mock:   mmGetProductBySku.mock,
		params: &ProductRepositoryMockGetProductBySkuParams{ctx, sku},
	}
	mmGetProductBySku.expectations = append(mmGetProductBySku.expectations, expectation)
	return expectation
}

// Then sets up ProductRepository.GetProductBySku return parameters for the expectation previously defined by the When method
func (e *ProductRepositoryMockGetProductBySkuExpectation) Then(pp1 *mm_domain.ProductInfo, err error) *ProductRepositoryMock {
	e.results = &ProductRepositoryMockGetProductBySkuResults{pp1, err}
	return e.mock
}

// GetProductBySku implements domain.ProductRepository
func (mmGetProductBySku *ProductRepositoryMock) GetProductBySku(ctx context.Context, sku uint32) (pp1 *mm_domain.ProductInfo, err error) {
	mm_atomic.AddUint64(&mmGetProductBySku.beforeGetProductBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProductBySku.afterGetProductBySkuCounter, 1)

	if mmGetProductBySku.inspectFuncGetProductBySku != nil {
		mmGetProductBySku.inspectFuncGetProductBySku(ctx, sku)
	}

	mm_params := &ProductRepositoryMockGetProductBySkuParams{ctx, sku}

	// Record call args
	mmGetProductBySku.GetProductBySkuMock.mutex.Lock()
	mmGetProductBySku.GetProductBySkuMock.callArgs = append(mmGetProductBySku.GetProductBySkuMock.callArgs, mm_params)
	mmGetProductBySku.GetProductBySkuMock.mutex.Unlock()

	for _, e := range mmGetProductBySku.GetProductBySkuMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetProductBySku.GetProductBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProductBySku.GetProductBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProductBySku.GetProductBySkuMock.defaultExpectation.params
		mm_got := ProductRepositoryMockGetProductBySkuParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProductBySku.t.Errorf("ProductRepositoryMock.GetProductBySku got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProductBySku.GetProductBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProductBySku.t.Fatal("No results are set for the ProductRepositoryMock.GetProductBySku")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetProductBySku.funcGetProductBySku != nil {
		return mmGetProductBySku.funcGetProductBySku(ctx, sku)
	}
	mmGetProductBySku.t.Fatalf("Unexpected call to ProductRepositoryMock.GetProductBySku. %v %v", ctx, sku)
	return
}

// GetProductBySkuAfterCounter returns a count of finished ProductRepositoryMock.GetProductBySku invocations
func (mmGetProductBySku *ProductRepositoryMock) GetProductBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProductBySku.afterGetProductBySkuCounter)
}

// GetProductBySkuBeforeCounter returns a count of ProductRepositoryMock.GetProductBySku invocations
func (mmGetProductBySku *ProductRepositoryMock) GetProductBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProductBySku.beforeGetProductBySkuCounter)
}

// Calls returns a list of arguments used in each call to ProductRepositoryMock.GetProductBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProductBySku *mProductRepositoryMockGetProductBySku) Calls() []*ProductRepositoryMockGetProductBySkuParams {
	mmGetProductBySku.mutex.RLock()

	argCopy := make([]*ProductRepositoryMockGetProductBySkuParams, len(mmGetProductBySku.callArgs))
	copy(argCopy, mmGetProductBySku.callArgs)

	mmGetProductBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetProductBySkuDone returns true if the count of the GetProductBySku invocations corresponds
// the number of defined expectations
func (m *ProductRepositoryMock) MinimockGetProductBySkuDone() bool {
	for _, e := range m.GetProductBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductBySkuMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProductBySkuCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProductBySku != nil && mm_atomic.LoadUint64(&m.afterGetProductBySkuCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetProductBySkuInspect logs each unmet expectation
func (m *ProductRepositoryMock) MinimockGetProductBySkuInspect() {
	for _, e := range m.GetProductBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductRepositoryMock.GetProductBySku with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductBySkuMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProductBySkuCounter) < 1 {
		if m.GetProductBySkuMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ProductRepositoryMock.GetProductBySku")
		} else {
			m.t.Errorf("Expected call to ProductRepositoryMock.GetProductBySku with params: %#v", *m.GetProductBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProductBySku != nil && mm_atomic.LoadUint64(&m.afterGetProductBySkuCounter) < 1 {
		m.t.Error("Expected call to ProductRepositoryMock.GetProductBySku")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProductRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetListBySkusInspect()

		m.MinimockGetProductBySkuInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProductRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProductRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetListBySkusDone() &&
		m.MinimockGetProductBySkuDone()
}
