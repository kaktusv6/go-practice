package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/domain.StockRepository -o ./mocks\stock_repository_minimock.go -n StockRepositoryMock

import (
	"context"
	mm_domain "route256/checkout/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StockRepositoryMock implements domain.StockRepository
type StockRepositoryMock struct {
	t minimock.Tester

	funcGetListBySku          func(ctx context.Context, sku uint32) (spa1 []*mm_domain.Stock, err error)
	inspectFuncGetListBySku   func(ctx context.Context, sku uint32)
	afterGetListBySkuCounter  uint64
	beforeGetListBySkuCounter uint64
	GetListBySkuMock          mStockRepositoryMockGetListBySku
}

// NewStockRepositoryMock returns a mock for domain.StockRepository
func NewStockRepositoryMock(t minimock.Tester) *StockRepositoryMock {
	m := &StockRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetListBySkuMock = mStockRepositoryMockGetListBySku{mock: m}
	m.GetListBySkuMock.callArgs = []*StockRepositoryMockGetListBySkuParams{}

	return m
}

type mStockRepositoryMockGetListBySku struct {
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockGetListBySkuExpectation
	expectations       []*StockRepositoryMockGetListBySkuExpectation

	callArgs []*StockRepositoryMockGetListBySkuParams
	mutex    sync.RWMutex
}

// StockRepositoryMockGetListBySkuExpectation specifies expectation struct of the StockRepository.GetListBySku
type StockRepositoryMockGetListBySkuExpectation struct {
	mock    *StockRepositoryMock
	params  *StockRepositoryMockGetListBySkuParams
	results *StockRepositoryMockGetListBySkuResults
	Counter uint64
}

// StockRepositoryMockGetListBySkuParams contains parameters of the StockRepository.GetListBySku
type StockRepositoryMockGetListBySkuParams struct {
	ctx context.Context
	sku uint32
}

// StockRepositoryMockGetListBySkuResults contains results of the StockRepository.GetListBySku
type StockRepositoryMockGetListBySkuResults struct {
	spa1 []*mm_domain.Stock
	err  error
}

// Expect sets up expected params for StockRepository.GetListBySku
func (mmGetListBySku *mStockRepositoryMockGetListBySku) Expect(ctx context.Context, sku uint32) *mStockRepositoryMockGetListBySku {
	if mmGetListBySku.mock.funcGetListBySku != nil {
		mmGetListBySku.mock.t.Fatalf("StockRepositoryMock.GetListBySku mock is already set by Set")
	}

	if mmGetListBySku.defaultExpectation == nil {
		mmGetListBySku.defaultExpectation = &StockRepositoryMockGetListBySkuExpectation{}
	}

	mmGetListBySku.defaultExpectation.params = &StockRepositoryMockGetListBySkuParams{ctx, sku}
	for _, e := range mmGetListBySku.expectations {
		if minimock.Equal(e.params, mmGetListBySku.defaultExpectation.params) {
			mmGetListBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListBySku.defaultExpectation.params)
		}
	}

	return mmGetListBySku
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.GetListBySku
func (mmGetListBySku *mStockRepositoryMockGetListBySku) Inspect(f func(ctx context.Context, sku uint32)) *mStockRepositoryMockGetListBySku {
	if mmGetListBySku.mock.inspectFuncGetListBySku != nil {
		mmGetListBySku.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.GetListBySku")
	}

	mmGetListBySku.mock.inspectFuncGetListBySku = f

	return mmGetListBySku
}

// Return sets up results that will be returned by StockRepository.GetListBySku
func (mmGetListBySku *mStockRepositoryMockGetListBySku) Return(spa1 []*mm_domain.Stock, err error) *StockRepositoryMock {
	if mmGetListBySku.mock.funcGetListBySku != nil {
		mmGetListBySku.mock.t.Fatalf("StockRepositoryMock.GetListBySku mock is already set by Set")
	}

	if mmGetListBySku.defaultExpectation == nil {
		mmGetListBySku.defaultExpectation = &StockRepositoryMockGetListBySkuExpectation{mock: mmGetListBySku.mock}
	}
	mmGetListBySku.defaultExpectation.results = &StockRepositoryMockGetListBySkuResults{spa1, err}
	return mmGetListBySku.mock
}

// Set uses given function f to mock the StockRepository.GetListBySku method
func (mmGetListBySku *mStockRepositoryMockGetListBySku) Set(f func(ctx context.Context, sku uint32) (spa1 []*mm_domain.Stock, err error)) *StockRepositoryMock {
	if mmGetListBySku.defaultExpectation != nil {
		mmGetListBySku.mock.t.Fatalf("Default expectation is already set for the StockRepository.GetListBySku method")
	}

	if len(mmGetListBySku.expectations) > 0 {
		mmGetListBySku.mock.t.Fatalf("Some expectations are already set for the StockRepository.GetListBySku method")
	}

	mmGetListBySku.mock.funcGetListBySku = f
	return mmGetListBySku.mock
}

// When sets expectation for the StockRepository.GetListBySku which will trigger the result defined by the following
// Then helper
func (mmGetListBySku *mStockRepositoryMockGetListBySku) When(ctx context.Context, sku uint32) *StockRepositoryMockGetListBySkuExpectation {
	if mmGetListBySku.mock.funcGetListBySku != nil {
		mmGetListBySku.mock.t.Fatalf("StockRepositoryMock.GetListBySku mock is already set by Set")
	}

	expectation := &StockRepositoryMockGetListBySkuExpectation{
		mock:   mmGetListBySku.mock,
		params: &StockRepositoryMockGetListBySkuParams{ctx, sku},
	}
	mmGetListBySku.expectations = append(mmGetListBySku.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.GetListBySku return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockGetListBySkuExpectation) Then(spa1 []*mm_domain.Stock, err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockGetListBySkuResults{spa1, err}
	return e.mock
}

// GetListBySku implements domain.StockRepository
func (mmGetListBySku *StockRepositoryMock) GetListBySku(ctx context.Context, sku uint32) (spa1 []*mm_domain.Stock, err error) {
	mm_atomic.AddUint64(&mmGetListBySku.beforeGetListBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListBySku.afterGetListBySkuCounter, 1)

	if mmGetListBySku.inspectFuncGetListBySku != nil {
		mmGetListBySku.inspectFuncGetListBySku(ctx, sku)
	}

	mm_params := &StockRepositoryMockGetListBySkuParams{ctx, sku}

	// Record call args
	mmGetListBySku.GetListBySkuMock.mutex.Lock()
	mmGetListBySku.GetListBySkuMock.callArgs = append(mmGetListBySku.GetListBySkuMock.callArgs, mm_params)
	mmGetListBySku.GetListBySkuMock.mutex.Unlock()

	for _, e := range mmGetListBySku.GetListBySkuMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.spa1, e.results.err
		}
	}

	if mmGetListBySku.GetListBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListBySku.GetListBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListBySku.GetListBySkuMock.defaultExpectation.params
		mm_got := StockRepositoryMockGetListBySkuParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListBySku.t.Errorf("StockRepositoryMock.GetListBySku got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListBySku.GetListBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListBySku.t.Fatal("No results are set for the StockRepositoryMock.GetListBySku")
		}
		return (*mm_results).spa1, (*mm_results).err
	}
	if mmGetListBySku.funcGetListBySku != nil {
		return mmGetListBySku.funcGetListBySku(ctx, sku)
	}
	mmGetListBySku.t.Fatalf("Unexpected call to StockRepositoryMock.GetListBySku. %v %v", ctx, sku)
	return
}

// GetListBySkuAfterCounter returns a count of finished StockRepositoryMock.GetListBySku invocations
func (mmGetListBySku *StockRepositoryMock) GetListBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListBySku.afterGetListBySkuCounter)
}

// GetListBySkuBeforeCounter returns a count of StockRepositoryMock.GetListBySku invocations
func (mmGetListBySku *StockRepositoryMock) GetListBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListBySku.beforeGetListBySkuCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.GetListBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListBySku *mStockRepositoryMockGetListBySku) Calls() []*StockRepositoryMockGetListBySkuParams {
	mmGetListBySku.mutex.RLock()

	argCopy := make([]*StockRepositoryMockGetListBySkuParams, len(mmGetListBySku.callArgs))
	copy(argCopy, mmGetListBySku.callArgs)

	mmGetListBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetListBySkuDone returns true if the count of the GetListBySku invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockGetListBySkuDone() bool {
	for _, e := range m.GetListBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListBySkuMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListBySkuCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListBySku != nil && mm_atomic.LoadUint64(&m.afterGetListBySkuCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListBySkuInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockGetListBySkuInspect() {
	for _, e := range m.GetListBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.GetListBySku with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListBySkuMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListBySkuCounter) < 1 {
		if m.GetListBySkuMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockRepositoryMock.GetListBySku")
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.GetListBySku with params: %#v", *m.GetListBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListBySku != nil && mm_atomic.LoadUint64(&m.afterGetListBySkuCounter) < 1 {
		m.t.Error("Expected call to StockRepositoryMock.GetListBySku")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetListBySkuInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetListBySkuDone()
}
