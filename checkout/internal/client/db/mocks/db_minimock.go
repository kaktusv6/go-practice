package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/libs/db.DB -o ./mocks\db_minimock.go -n DBMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v4"
)

// DBMock implements db.DB
type DBMock struct {
	t minimock.Tester

	funcBeginTx          func(ctx context.Context, txOptions pgx.TxOptions) (t1 pgx.Tx, err error)
	inspectFuncBeginTx   func(ctx context.Context, txOptions pgx.TxOptions)
	afterBeginTxCounter  uint64
	beforeBeginTxCounter uint64
	BeginTxMock          mDBMockBeginTx

	funcClose          func()
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mDBMockClose

	funcPing          func(ctx context.Context) (err error)
	inspectFuncPing   func(ctx context.Context)
	afterPingCounter  uint64
	beforePingCounter uint64
	PingMock          mDBMockPing

	funcQuery          func(ctx context.Context, query string, args ...interface{}) (r1 pgx.Rows, err error)
	inspectFuncQuery   func(ctx context.Context, query string, args ...interface{})
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mDBMockQuery

	funcQueryRow          func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Row)
	inspectFuncQueryRow   func(ctx context.Context, sql string, args ...interface{})
	afterQueryRowCounter  uint64
	beforeQueryRowCounter uint64
	QueryRowMock          mDBMockQueryRow
}

// NewDBMock returns a mock for db.DB
func NewDBMock(t minimock.Tester) *DBMock {
	m := &DBMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginTxMock = mDBMockBeginTx{mock: m}
	m.BeginTxMock.callArgs = []*DBMockBeginTxParams{}

	m.CloseMock = mDBMockClose{mock: m}

	m.PingMock = mDBMockPing{mock: m}
	m.PingMock.callArgs = []*DBMockPingParams{}

	m.QueryMock = mDBMockQuery{mock: m}
	m.QueryMock.callArgs = []*DBMockQueryParams{}

	m.QueryRowMock = mDBMockQueryRow{mock: m}
	m.QueryRowMock.callArgs = []*DBMockQueryRowParams{}

	return m
}

type mDBMockBeginTx struct {
	mock               *DBMock
	defaultExpectation *DBMockBeginTxExpectation
	expectations       []*DBMockBeginTxExpectation

	callArgs []*DBMockBeginTxParams
	mutex    sync.RWMutex
}

// DBMockBeginTxExpectation specifies expectation struct of the DB.BeginTx
type DBMockBeginTxExpectation struct {
	mock    *DBMock
	params  *DBMockBeginTxParams
	results *DBMockBeginTxResults
	Counter uint64
}

// DBMockBeginTxParams contains parameters of the DB.BeginTx
type DBMockBeginTxParams struct {
	ctx       context.Context
	txOptions pgx.TxOptions
}

// DBMockBeginTxResults contains results of the DB.BeginTx
type DBMockBeginTxResults struct {
	t1  pgx.Tx
	err error
}

// Expect sets up expected params for DB.BeginTx
func (mmBeginTx *mDBMockBeginTx) Expect(ctx context.Context, txOptions pgx.TxOptions) *mDBMockBeginTx {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by Set")
	}

	if mmBeginTx.defaultExpectation == nil {
		mmBeginTx.defaultExpectation = &DBMockBeginTxExpectation{}
	}

	mmBeginTx.defaultExpectation.params = &DBMockBeginTxParams{ctx, txOptions}
	for _, e := range mmBeginTx.expectations {
		if minimock.Equal(e.params, mmBeginTx.defaultExpectation.params) {
			mmBeginTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBeginTx.defaultExpectation.params)
		}
	}

	return mmBeginTx
}

// Inspect accepts an inspector function that has same arguments as the DB.BeginTx
func (mmBeginTx *mDBMockBeginTx) Inspect(f func(ctx context.Context, txOptions pgx.TxOptions)) *mDBMockBeginTx {
	if mmBeginTx.mock.inspectFuncBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("Inspect function is already set for DBMock.BeginTx")
	}

	mmBeginTx.mock.inspectFuncBeginTx = f

	return mmBeginTx
}

// Return sets up results that will be returned by DB.BeginTx
func (mmBeginTx *mDBMockBeginTx) Return(t1 pgx.Tx, err error) *DBMock {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by Set")
	}

	if mmBeginTx.defaultExpectation == nil {
		mmBeginTx.defaultExpectation = &DBMockBeginTxExpectation{mock: mmBeginTx.mock}
	}
	mmBeginTx.defaultExpectation.results = &DBMockBeginTxResults{t1, err}
	return mmBeginTx.mock
}

// Set uses given function f to mock the DB.BeginTx method
func (mmBeginTx *mDBMockBeginTx) Set(f func(ctx context.Context, txOptions pgx.TxOptions) (t1 pgx.Tx, err error)) *DBMock {
	if mmBeginTx.defaultExpectation != nil {
		mmBeginTx.mock.t.Fatalf("Default expectation is already set for the DB.BeginTx method")
	}

	if len(mmBeginTx.expectations) > 0 {
		mmBeginTx.mock.t.Fatalf("Some expectations are already set for the DB.BeginTx method")
	}

	mmBeginTx.mock.funcBeginTx = f
	return mmBeginTx.mock
}

// When sets expectation for the DB.BeginTx which will trigger the result defined by the following
// Then helper
func (mmBeginTx *mDBMockBeginTx) When(ctx context.Context, txOptions pgx.TxOptions) *DBMockBeginTxExpectation {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by Set")
	}

	expectation := &DBMockBeginTxExpectation{
		mock:   mmBeginTx.mock,
		params: &DBMockBeginTxParams{ctx, txOptions},
	}
	mmBeginTx.expectations = append(mmBeginTx.expectations, expectation)
	return expectation
}

// Then sets up DB.BeginTx return parameters for the expectation previously defined by the When method
func (e *DBMockBeginTxExpectation) Then(t1 pgx.Tx, err error) *DBMock {
	e.results = &DBMockBeginTxResults{t1, err}
	return e.mock
}

// BeginTx implements db.DB
func (mmBeginTx *DBMock) BeginTx(ctx context.Context, txOptions pgx.TxOptions) (t1 pgx.Tx, err error) {
	mm_atomic.AddUint64(&mmBeginTx.beforeBeginTxCounter, 1)
	defer mm_atomic.AddUint64(&mmBeginTx.afterBeginTxCounter, 1)

	if mmBeginTx.inspectFuncBeginTx != nil {
		mmBeginTx.inspectFuncBeginTx(ctx, txOptions)
	}

	mm_params := &DBMockBeginTxParams{ctx, txOptions}

	// Record call args
	mmBeginTx.BeginTxMock.mutex.Lock()
	mmBeginTx.BeginTxMock.callArgs = append(mmBeginTx.BeginTxMock.callArgs, mm_params)
	mmBeginTx.BeginTxMock.mutex.Unlock()

	for _, e := range mmBeginTx.BeginTxMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmBeginTx.BeginTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeginTx.BeginTxMock.defaultExpectation.Counter, 1)
		mm_want := mmBeginTx.BeginTxMock.defaultExpectation.params
		mm_got := DBMockBeginTxParams{ctx, txOptions}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBeginTx.t.Errorf("DBMock.BeginTx got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBeginTx.BeginTxMock.defaultExpectation.results
		if mm_results == nil {
			mmBeginTx.t.Fatal("No results are set for the DBMock.BeginTx")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmBeginTx.funcBeginTx != nil {
		return mmBeginTx.funcBeginTx(ctx, txOptions)
	}
	mmBeginTx.t.Fatalf("Unexpected call to DBMock.BeginTx. %v %v", ctx, txOptions)
	return
}

// BeginTxAfterCounter returns a count of finished DBMock.BeginTx invocations
func (mmBeginTx *DBMock) BeginTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTx.afterBeginTxCounter)
}

// BeginTxBeforeCounter returns a count of DBMock.BeginTx invocations
func (mmBeginTx *DBMock) BeginTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTx.beforeBeginTxCounter)
}

// Calls returns a list of arguments used in each call to DBMock.BeginTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBeginTx *mDBMockBeginTx) Calls() []*DBMockBeginTxParams {
	mmBeginTx.mutex.RLock()

	argCopy := make([]*DBMockBeginTxParams, len(mmBeginTx.callArgs))
	copy(argCopy, mmBeginTx.callArgs)

	mmBeginTx.mutex.RUnlock()

	return argCopy
}

// MinimockBeginTxDone returns true if the count of the BeginTx invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockBeginTxDone() bool {
	for _, e := range m.BeginTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginTx != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginTxInspect logs each unmet expectation
func (m *DBMock) MinimockBeginTxInspect() {
	for _, e := range m.BeginTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.BeginTx with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		if m.BeginTxMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.BeginTx")
		} else {
			m.t.Errorf("Expected call to DBMock.BeginTx with params: %#v", *m.BeginTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginTx != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		m.t.Error("Expected call to DBMock.BeginTx")
	}
}

type mDBMockClose struct {
	mock               *DBMock
	defaultExpectation *DBMockCloseExpectation
	expectations       []*DBMockCloseExpectation
}

// DBMockCloseExpectation specifies expectation struct of the DB.Close
type DBMockCloseExpectation struct {
	mock *DBMock

	Counter uint64
}

// Expect sets up expected params for DB.Close
func (mmClose *mDBMockClose) Expect() *mDBMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("DBMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &DBMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the DB.Close
func (mmClose *mDBMockClose) Inspect(f func()) *mDBMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for DBMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by DB.Close
func (mmClose *mDBMockClose) Return() *DBMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("DBMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &DBMockCloseExpectation{mock: mmClose.mock}
	}

	return mmClose.mock
}

// Set uses given function f to mock the DB.Close method
func (mmClose *mDBMockClose) Set(f func()) *DBMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the DB.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the DB.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements db.DB
func (mmClose *DBMock) Close() {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClose.funcClose != nil {
		mmClose.funcClose()
		return
	}
	mmClose.t.Fatalf("Unexpected call to DBMock.Close.")

}

// CloseAfterCounter returns a count of finished DBMock.Close invocations
func (mmClose *DBMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of DBMock.Close invocations
func (mmClose *DBMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *DBMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DBMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to DBMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to DBMock.Close")
	}
}

type mDBMockPing struct {
	mock               *DBMock
	defaultExpectation *DBMockPingExpectation
	expectations       []*DBMockPingExpectation

	callArgs []*DBMockPingParams
	mutex    sync.RWMutex
}

// DBMockPingExpectation specifies expectation struct of the DB.Ping
type DBMockPingExpectation struct {
	mock    *DBMock
	params  *DBMockPingParams
	results *DBMockPingResults
	Counter uint64
}

// DBMockPingParams contains parameters of the DB.Ping
type DBMockPingParams struct {
	ctx context.Context
}

// DBMockPingResults contains results of the DB.Ping
type DBMockPingResults struct {
	err error
}

// Expect sets up expected params for DB.Ping
func (mmPing *mDBMockPing) Expect(ctx context.Context) *mDBMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("DBMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &DBMockPingExpectation{}
	}

	mmPing.defaultExpectation.params = &DBMockPingParams{ctx}
	for _, e := range mmPing.expectations {
		if minimock.Equal(e.params, mmPing.defaultExpectation.params) {
			mmPing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPing.defaultExpectation.params)
		}
	}

	return mmPing
}

// Inspect accepts an inspector function that has same arguments as the DB.Ping
func (mmPing *mDBMockPing) Inspect(f func(ctx context.Context)) *mDBMockPing {
	if mmPing.mock.inspectFuncPing != nil {
		mmPing.mock.t.Fatalf("Inspect function is already set for DBMock.Ping")
	}

	mmPing.mock.inspectFuncPing = f

	return mmPing
}

// Return sets up results that will be returned by DB.Ping
func (mmPing *mDBMockPing) Return(err error) *DBMock {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("DBMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &DBMockPingExpectation{mock: mmPing.mock}
	}
	mmPing.defaultExpectation.results = &DBMockPingResults{err}
	return mmPing.mock
}

// Set uses given function f to mock the DB.Ping method
func (mmPing *mDBMockPing) Set(f func(ctx context.Context) (err error)) *DBMock {
	if mmPing.defaultExpectation != nil {
		mmPing.mock.t.Fatalf("Default expectation is already set for the DB.Ping method")
	}

	if len(mmPing.expectations) > 0 {
		mmPing.mock.t.Fatalf("Some expectations are already set for the DB.Ping method")
	}

	mmPing.mock.funcPing = f
	return mmPing.mock
}

// When sets expectation for the DB.Ping which will trigger the result defined by the following
// Then helper
func (mmPing *mDBMockPing) When(ctx context.Context) *DBMockPingExpectation {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("DBMock.Ping mock is already set by Set")
	}

	expectation := &DBMockPingExpectation{
		mock:   mmPing.mock,
		params: &DBMockPingParams{ctx},
	}
	mmPing.expectations = append(mmPing.expectations, expectation)
	return expectation
}

// Then sets up DB.Ping return parameters for the expectation previously defined by the When method
func (e *DBMockPingExpectation) Then(err error) *DBMock {
	e.results = &DBMockPingResults{err}
	return e.mock
}

// Ping implements db.DB
func (mmPing *DBMock) Ping(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmPing.beforePingCounter, 1)
	defer mm_atomic.AddUint64(&mmPing.afterPingCounter, 1)

	if mmPing.inspectFuncPing != nil {
		mmPing.inspectFuncPing(ctx)
	}

	mm_params := &DBMockPingParams{ctx}

	// Record call args
	mmPing.PingMock.mutex.Lock()
	mmPing.PingMock.callArgs = append(mmPing.PingMock.callArgs, mm_params)
	mmPing.PingMock.mutex.Unlock()

	for _, e := range mmPing.PingMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPing.PingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPing.PingMock.defaultExpectation.Counter, 1)
		mm_want := mmPing.PingMock.defaultExpectation.params
		mm_got := DBMockPingParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPing.t.Errorf("DBMock.Ping got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPing.PingMock.defaultExpectation.results
		if mm_results == nil {
			mmPing.t.Fatal("No results are set for the DBMock.Ping")
		}
		return (*mm_results).err
	}
	if mmPing.funcPing != nil {
		return mmPing.funcPing(ctx)
	}
	mmPing.t.Fatalf("Unexpected call to DBMock.Ping. %v", ctx)
	return
}

// PingAfterCounter returns a count of finished DBMock.Ping invocations
func (mmPing *DBMock) PingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.afterPingCounter)
}

// PingBeforeCounter returns a count of DBMock.Ping invocations
func (mmPing *DBMock) PingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.beforePingCounter)
}

// Calls returns a list of arguments used in each call to DBMock.Ping.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPing *mDBMockPing) Calls() []*DBMockPingParams {
	mmPing.mutex.RLock()

	argCopy := make([]*DBMockPingParams, len(mmPing.callArgs))
	copy(argCopy, mmPing.callArgs)

	mmPing.mutex.RUnlock()

	return argCopy
}

// MinimockPingDone returns true if the count of the Ping invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockPingDone() bool {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		return false
	}
	return true
}

// MinimockPingInspect logs each unmet expectation
func (m *DBMock) MinimockPingInspect() {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.Ping with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		if m.PingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.Ping")
		} else {
			m.t.Errorf("Expected call to DBMock.Ping with params: %#v", *m.PingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		m.t.Error("Expected call to DBMock.Ping")
	}
}

type mDBMockQuery struct {
	mock               *DBMock
	defaultExpectation *DBMockQueryExpectation
	expectations       []*DBMockQueryExpectation

	callArgs []*DBMockQueryParams
	mutex    sync.RWMutex
}

// DBMockQueryExpectation specifies expectation struct of the DB.Query
type DBMockQueryExpectation struct {
	mock    *DBMock
	params  *DBMockQueryParams
	results *DBMockQueryResults
	Counter uint64
}

// DBMockQueryParams contains parameters of the DB.Query
type DBMockQueryParams struct {
	ctx   context.Context
	query string
	args  []interface{}
}

// DBMockQueryResults contains results of the DB.Query
type DBMockQueryResults struct {
	r1  pgx.Rows
	err error
}

// Expect sets up expected params for DB.Query
func (mmQuery *mDBMockQuery) Expect(ctx context.Context, query string, args ...interface{}) *mDBMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("DBMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &DBMockQueryExpectation{}
	}

	mmQuery.defaultExpectation.params = &DBMockQueryParams{ctx, query, args}
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the DB.Query
func (mmQuery *mDBMockQuery) Inspect(f func(ctx context.Context, query string, args ...interface{})) *mDBMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for DBMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by DB.Query
func (mmQuery *mDBMockQuery) Return(r1 pgx.Rows, err error) *DBMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("DBMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &DBMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &DBMockQueryResults{r1, err}
	return mmQuery.mock
}

// Set uses given function f to mock the DB.Query method
func (mmQuery *mDBMockQuery) Set(f func(ctx context.Context, query string, args ...interface{}) (r1 pgx.Rows, err error)) *DBMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the DB.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the DB.Query method")
	}

	mmQuery.mock.funcQuery = f
	return mmQuery.mock
}

// When sets expectation for the DB.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mDBMockQuery) When(ctx context.Context, query string, args ...interface{}) *DBMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("DBMock.Query mock is already set by Set")
	}

	expectation := &DBMockQueryExpectation{
		mock:   mmQuery.mock,
		params: &DBMockQueryParams{ctx, query, args},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up DB.Query return parameters for the expectation previously defined by the When method
func (e *DBMockQueryExpectation) Then(r1 pgx.Rows, err error) *DBMock {
	e.results = &DBMockQueryResults{r1, err}
	return e.mock
}

// Query implements db.DB
func (mmQuery *DBMock) Query(ctx context.Context, query string, args ...interface{}) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, query, args...)
	}

	mm_params := &DBMockQueryParams{ctx, query, args}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_got := DBMockQueryParams{ctx, query, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("DBMock.Query got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the DBMock.Query")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, query, args...)
	}
	mmQuery.t.Fatalf("Unexpected call to DBMock.Query. %v %v %v", ctx, query, args)
	return
}

// QueryAfterCounter returns a count of finished DBMock.Query invocations
func (mmQuery *DBMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of DBMock.Query invocations
func (mmQuery *DBMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to DBMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mDBMockQuery) Calls() []*DBMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*DBMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockQueryDone() bool {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryInspect logs each unmet expectation
func (m *DBMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.Query with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.Query")
		} else {
			m.t.Errorf("Expected call to DBMock.Query with params: %#v", *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		m.t.Error("Expected call to DBMock.Query")
	}
}

type mDBMockQueryRow struct {
	mock               *DBMock
	defaultExpectation *DBMockQueryRowExpectation
	expectations       []*DBMockQueryRowExpectation

	callArgs []*DBMockQueryRowParams
	mutex    sync.RWMutex
}

// DBMockQueryRowExpectation specifies expectation struct of the DB.QueryRow
type DBMockQueryRowExpectation struct {
	mock    *DBMock
	params  *DBMockQueryRowParams
	results *DBMockQueryRowResults
	Counter uint64
}

// DBMockQueryRowParams contains parameters of the DB.QueryRow
type DBMockQueryRowParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// DBMockQueryRowResults contains results of the DB.QueryRow
type DBMockQueryRowResults struct {
	r1 pgx.Row
}

// Expect sets up expected params for DB.QueryRow
func (mmQueryRow *mDBMockQueryRow) Expect(ctx context.Context, sql string, args ...interface{}) *mDBMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("DBMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &DBMockQueryRowExpectation{}
	}

	mmQueryRow.defaultExpectation.params = &DBMockQueryRowParams{ctx, sql, args}
	for _, e := range mmQueryRow.expectations {
		if minimock.Equal(e.params, mmQueryRow.defaultExpectation.params) {
			mmQueryRow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRow.defaultExpectation.params)
		}
	}

	return mmQueryRow
}

// Inspect accepts an inspector function that has same arguments as the DB.QueryRow
func (mmQueryRow *mDBMockQueryRow) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mDBMockQueryRow {
	if mmQueryRow.mock.inspectFuncQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("Inspect function is already set for DBMock.QueryRow")
	}

	mmQueryRow.mock.inspectFuncQueryRow = f

	return mmQueryRow
}

// Return sets up results that will be returned by DB.QueryRow
func (mmQueryRow *mDBMockQueryRow) Return(r1 pgx.Row) *DBMock {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("DBMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &DBMockQueryRowExpectation{mock: mmQueryRow.mock}
	}
	mmQueryRow.defaultExpectation.results = &DBMockQueryRowResults{r1}
	return mmQueryRow.mock
}

// Set uses given function f to mock the DB.QueryRow method
func (mmQueryRow *mDBMockQueryRow) Set(f func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Row)) *DBMock {
	if mmQueryRow.defaultExpectation != nil {
		mmQueryRow.mock.t.Fatalf("Default expectation is already set for the DB.QueryRow method")
	}

	if len(mmQueryRow.expectations) > 0 {
		mmQueryRow.mock.t.Fatalf("Some expectations are already set for the DB.QueryRow method")
	}

	mmQueryRow.mock.funcQueryRow = f
	return mmQueryRow.mock
}

// When sets expectation for the DB.QueryRow which will trigger the result defined by the following
// Then helper
func (mmQueryRow *mDBMockQueryRow) When(ctx context.Context, sql string, args ...interface{}) *DBMockQueryRowExpectation {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("DBMock.QueryRow mock is already set by Set")
	}

	expectation := &DBMockQueryRowExpectation{
		mock:   mmQueryRow.mock,
		params: &DBMockQueryRowParams{ctx, sql, args},
	}
	mmQueryRow.expectations = append(mmQueryRow.expectations, expectation)
	return expectation
}

// Then sets up DB.QueryRow return parameters for the expectation previously defined by the When method
func (e *DBMockQueryRowExpectation) Then(r1 pgx.Row) *DBMock {
	e.results = &DBMockQueryRowResults{r1}
	return e.mock
}

// QueryRow implements db.DB
func (mmQueryRow *DBMock) QueryRow(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRow.beforeQueryRowCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRow.afterQueryRowCounter, 1)

	if mmQueryRow.inspectFuncQueryRow != nil {
		mmQueryRow.inspectFuncQueryRow(ctx, sql, args...)
	}

	mm_params := &DBMockQueryRowParams{ctx, sql, args}

	// Record call args
	mmQueryRow.QueryRowMock.mutex.Lock()
	mmQueryRow.QueryRowMock.callArgs = append(mmQueryRow.QueryRowMock.callArgs, mm_params)
	mmQueryRow.QueryRowMock.mutex.Unlock()

	for _, e := range mmQueryRow.QueryRowMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRow.QueryRowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRow.QueryRowMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRow.QueryRowMock.defaultExpectation.params
		mm_got := DBMockQueryRowParams{ctx, sql, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRow.t.Errorf("DBMock.QueryRow got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRow.QueryRowMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRow.t.Fatal("No results are set for the DBMock.QueryRow")
		}
		return (*mm_results).r1
	}
	if mmQueryRow.funcQueryRow != nil {
		return mmQueryRow.funcQueryRow(ctx, sql, args...)
	}
	mmQueryRow.t.Fatalf("Unexpected call to DBMock.QueryRow. %v %v %v", ctx, sql, args)
	return
}

// QueryRowAfterCounter returns a count of finished DBMock.QueryRow invocations
func (mmQueryRow *DBMock) QueryRowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.afterQueryRowCounter)
}

// QueryRowBeforeCounter returns a count of DBMock.QueryRow invocations
func (mmQueryRow *DBMock) QueryRowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.beforeQueryRowCounter)
}

// Calls returns a list of arguments used in each call to DBMock.QueryRow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRow *mDBMockQueryRow) Calls() []*DBMockQueryRowParams {
	mmQueryRow.mutex.RLock()

	argCopy := make([]*DBMockQueryRowParams, len(mmQueryRow.callArgs))
	copy(argCopy, mmQueryRow.callArgs)

	mmQueryRow.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowDone returns true if the count of the QueryRow invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockQueryRowDone() bool {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryRowInspect logs each unmet expectation
func (m *DBMock) MinimockQueryRowInspect() {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.QueryRow with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		if m.QueryRowMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.QueryRow")
		} else {
			m.t.Errorf("Expected call to DBMock.QueryRow with params: %#v", *m.QueryRowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		m.t.Error("Expected call to DBMock.QueryRow")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DBMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBeginTxInspect()

		m.MinimockCloseInspect()

		m.MinimockPingInspect()

		m.MinimockQueryInspect()

		m.MinimockQueryRowInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginTxDone() &&
		m.MinimockCloseDone() &&
		m.MinimockPingDone() &&
		m.MinimockQueryDone() &&
		m.MinimockQueryRowDone()
}
