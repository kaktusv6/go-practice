package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/libs/db.QueryEngine -o ./mocks\query_engine_minimock.go -n QueryEngineMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v4"
)

// QueryEngineMock implements db.QueryEngine
type QueryEngineMock struct {
	t minimock.Tester

	funcQuery          func(ctx context.Context, query string, args ...interface{}) (r1 pgx.Rows, err error)
	inspectFuncQuery   func(ctx context.Context, query string, args ...interface{})
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mQueryEngineMockQuery

	funcQueryRow          func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Row)
	inspectFuncQueryRow   func(ctx context.Context, sql string, args ...interface{})
	afterQueryRowCounter  uint64
	beforeQueryRowCounter uint64
	QueryRowMock          mQueryEngineMockQueryRow
}

// NewQueryEngineMock returns a mock for db.QueryEngine
func NewQueryEngineMock(t minimock.Tester) *QueryEngineMock {
	m := &QueryEngineMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.QueryMock = mQueryEngineMockQuery{mock: m}
	m.QueryMock.callArgs = []*QueryEngineMockQueryParams{}

	m.QueryRowMock = mQueryEngineMockQueryRow{mock: m}
	m.QueryRowMock.callArgs = []*QueryEngineMockQueryRowParams{}

	return m
}

type mQueryEngineMockQuery struct {
	mock               *QueryEngineMock
	defaultExpectation *QueryEngineMockQueryExpectation
	expectations       []*QueryEngineMockQueryExpectation

	callArgs []*QueryEngineMockQueryParams
	mutex    sync.RWMutex
}

// QueryEngineMockQueryExpectation specifies expectation struct of the QueryEngine.Query
type QueryEngineMockQueryExpectation struct {
	mock    *QueryEngineMock
	params  *QueryEngineMockQueryParams
	results *QueryEngineMockQueryResults
	Counter uint64
}

// QueryEngineMockQueryParams contains parameters of the QueryEngine.Query
type QueryEngineMockQueryParams struct {
	ctx   context.Context
	query string
	args  []interface{}
}

// QueryEngineMockQueryResults contains results of the QueryEngine.Query
type QueryEngineMockQueryResults struct {
	r1  pgx.Rows
	err error
}

// Expect sets up expected params for QueryEngine.Query
func (mmQuery *mQueryEngineMockQuery) Expect(ctx context.Context, query string, args ...interface{}) *mQueryEngineMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("QueryEngineMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &QueryEngineMockQueryExpectation{}
	}

	mmQuery.defaultExpectation.params = &QueryEngineMockQueryParams{ctx, query, args}
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the QueryEngine.Query
func (mmQuery *mQueryEngineMockQuery) Inspect(f func(ctx context.Context, query string, args ...interface{})) *mQueryEngineMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for QueryEngineMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by QueryEngine.Query
func (mmQuery *mQueryEngineMockQuery) Return(r1 pgx.Rows, err error) *QueryEngineMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("QueryEngineMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &QueryEngineMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &QueryEngineMockQueryResults{r1, err}
	return mmQuery.mock
}

// Set uses given function f to mock the QueryEngine.Query method
func (mmQuery *mQueryEngineMockQuery) Set(f func(ctx context.Context, query string, args ...interface{}) (r1 pgx.Rows, err error)) *QueryEngineMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the QueryEngine.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the QueryEngine.Query method")
	}

	mmQuery.mock.funcQuery = f
	return mmQuery.mock
}

// When sets expectation for the QueryEngine.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mQueryEngineMockQuery) When(ctx context.Context, query string, args ...interface{}) *QueryEngineMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("QueryEngineMock.Query mock is already set by Set")
	}

	expectation := &QueryEngineMockQueryExpectation{
		mock:   mmQuery.mock,
		params: &QueryEngineMockQueryParams{ctx, query, args},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up QueryEngine.Query return parameters for the expectation previously defined by the When method
func (e *QueryEngineMockQueryExpectation) Then(r1 pgx.Rows, err error) *QueryEngineMock {
	e.results = &QueryEngineMockQueryResults{r1, err}
	return e.mock
}

// Query implements db.QueryEngine
func (mmQuery *QueryEngineMock) Query(ctx context.Context, query string, args ...interface{}) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, query, args...)
	}

	mm_params := &QueryEngineMockQueryParams{ctx, query, args}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_got := QueryEngineMockQueryParams{ctx, query, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("QueryEngineMock.Query got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the QueryEngineMock.Query")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, query, args...)
	}
	mmQuery.t.Fatalf("Unexpected call to QueryEngineMock.Query. %v %v %v", ctx, query, args)
	return
}

// QueryAfterCounter returns a count of finished QueryEngineMock.Query invocations
func (mmQuery *QueryEngineMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of QueryEngineMock.Query invocations
func (mmQuery *QueryEngineMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to QueryEngineMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mQueryEngineMockQuery) Calls() []*QueryEngineMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*QueryEngineMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *QueryEngineMock) MinimockQueryDone() bool {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryInspect logs each unmet expectation
func (m *QueryEngineMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QueryEngineMock.Query with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to QueryEngineMock.Query")
		} else {
			m.t.Errorf("Expected call to QueryEngineMock.Query with params: %#v", *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		m.t.Error("Expected call to QueryEngineMock.Query")
	}
}

type mQueryEngineMockQueryRow struct {
	mock               *QueryEngineMock
	defaultExpectation *QueryEngineMockQueryRowExpectation
	expectations       []*QueryEngineMockQueryRowExpectation

	callArgs []*QueryEngineMockQueryRowParams
	mutex    sync.RWMutex
}

// QueryEngineMockQueryRowExpectation specifies expectation struct of the QueryEngine.QueryRow
type QueryEngineMockQueryRowExpectation struct {
	mock    *QueryEngineMock
	params  *QueryEngineMockQueryRowParams
	results *QueryEngineMockQueryRowResults
	Counter uint64
}

// QueryEngineMockQueryRowParams contains parameters of the QueryEngine.QueryRow
type QueryEngineMockQueryRowParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// QueryEngineMockQueryRowResults contains results of the QueryEngine.QueryRow
type QueryEngineMockQueryRowResults struct {
	r1 pgx.Row
}

// Expect sets up expected params for QueryEngine.QueryRow
func (mmQueryRow *mQueryEngineMockQueryRow) Expect(ctx context.Context, sql string, args ...interface{}) *mQueryEngineMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("QueryEngineMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &QueryEngineMockQueryRowExpectation{}
	}

	mmQueryRow.defaultExpectation.params = &QueryEngineMockQueryRowParams{ctx, sql, args}
	for _, e := range mmQueryRow.expectations {
		if minimock.Equal(e.params, mmQueryRow.defaultExpectation.params) {
			mmQueryRow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRow.defaultExpectation.params)
		}
	}

	return mmQueryRow
}

// Inspect accepts an inspector function that has same arguments as the QueryEngine.QueryRow
func (mmQueryRow *mQueryEngineMockQueryRow) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mQueryEngineMockQueryRow {
	if mmQueryRow.mock.inspectFuncQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("Inspect function is already set for QueryEngineMock.QueryRow")
	}

	mmQueryRow.mock.inspectFuncQueryRow = f

	return mmQueryRow
}

// Return sets up results that will be returned by QueryEngine.QueryRow
func (mmQueryRow *mQueryEngineMockQueryRow) Return(r1 pgx.Row) *QueryEngineMock {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("QueryEngineMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &QueryEngineMockQueryRowExpectation{mock: mmQueryRow.mock}
	}
	mmQueryRow.defaultExpectation.results = &QueryEngineMockQueryRowResults{r1}
	return mmQueryRow.mock
}

// Set uses given function f to mock the QueryEngine.QueryRow method
func (mmQueryRow *mQueryEngineMockQueryRow) Set(f func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Row)) *QueryEngineMock {
	if mmQueryRow.defaultExpectation != nil {
		mmQueryRow.mock.t.Fatalf("Default expectation is already set for the QueryEngine.QueryRow method")
	}

	if len(mmQueryRow.expectations) > 0 {
		mmQueryRow.mock.t.Fatalf("Some expectations are already set for the QueryEngine.QueryRow method")
	}

	mmQueryRow.mock.funcQueryRow = f
	return mmQueryRow.mock
}

// When sets expectation for the QueryEngine.QueryRow which will trigger the result defined by the following
// Then helper
func (mmQueryRow *mQueryEngineMockQueryRow) When(ctx context.Context, sql string, args ...interface{}) *QueryEngineMockQueryRowExpectation {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("QueryEngineMock.QueryRow mock is already set by Set")
	}

	expectation := &QueryEngineMockQueryRowExpectation{
		mock:   mmQueryRow.mock,
		params: &QueryEngineMockQueryRowParams{ctx, sql, args},
	}
	mmQueryRow.expectations = append(mmQueryRow.expectations, expectation)
	return expectation
}

// Then sets up QueryEngine.QueryRow return parameters for the expectation previously defined by the When method
func (e *QueryEngineMockQueryRowExpectation) Then(r1 pgx.Row) *QueryEngineMock {
	e.results = &QueryEngineMockQueryRowResults{r1}
	return e.mock
}

// QueryRow implements db.QueryEngine
func (mmQueryRow *QueryEngineMock) QueryRow(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRow.beforeQueryRowCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRow.afterQueryRowCounter, 1)

	if mmQueryRow.inspectFuncQueryRow != nil {
		mmQueryRow.inspectFuncQueryRow(ctx, sql, args...)
	}

	mm_params := &QueryEngineMockQueryRowParams{ctx, sql, args}

	// Record call args
	mmQueryRow.QueryRowMock.mutex.Lock()
	mmQueryRow.QueryRowMock.callArgs = append(mmQueryRow.QueryRowMock.callArgs, mm_params)
	mmQueryRow.QueryRowMock.mutex.Unlock()

	for _, e := range mmQueryRow.QueryRowMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRow.QueryRowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRow.QueryRowMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRow.QueryRowMock.defaultExpectation.params
		mm_got := QueryEngineMockQueryRowParams{ctx, sql, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRow.t.Errorf("QueryEngineMock.QueryRow got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRow.QueryRowMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRow.t.Fatal("No results are set for the QueryEngineMock.QueryRow")
		}
		return (*mm_results).r1
	}
	if mmQueryRow.funcQueryRow != nil {
		return mmQueryRow.funcQueryRow(ctx, sql, args...)
	}
	mmQueryRow.t.Fatalf("Unexpected call to QueryEngineMock.QueryRow. %v %v %v", ctx, sql, args)
	return
}

// QueryRowAfterCounter returns a count of finished QueryEngineMock.QueryRow invocations
func (mmQueryRow *QueryEngineMock) QueryRowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.afterQueryRowCounter)
}

// QueryRowBeforeCounter returns a count of QueryEngineMock.QueryRow invocations
func (mmQueryRow *QueryEngineMock) QueryRowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.beforeQueryRowCounter)
}

// Calls returns a list of arguments used in each call to QueryEngineMock.QueryRow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRow *mQueryEngineMockQueryRow) Calls() []*QueryEngineMockQueryRowParams {
	mmQueryRow.mutex.RLock()

	argCopy := make([]*QueryEngineMockQueryRowParams, len(mmQueryRow.callArgs))
	copy(argCopy, mmQueryRow.callArgs)

	mmQueryRow.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowDone returns true if the count of the QueryRow invocations corresponds
// the number of defined expectations
func (m *QueryEngineMock) MinimockQueryRowDone() bool {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryRowInspect logs each unmet expectation
func (m *QueryEngineMock) MinimockQueryRowInspect() {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QueryEngineMock.QueryRow with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		if m.QueryRowMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to QueryEngineMock.QueryRow")
		} else {
			m.t.Errorf("Expected call to QueryEngineMock.QueryRow with params: %#v", *m.QueryRowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		m.t.Error("Expected call to QueryEngineMock.QueryRow")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *QueryEngineMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockQueryInspect()

		m.MinimockQueryRowInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *QueryEngineMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *QueryEngineMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockQueryDone() &&
		m.MinimockQueryRowDone()
}
